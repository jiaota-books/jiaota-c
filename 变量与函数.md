## 变量与函数

Hello World之后，下一步就是最简单的加减法演示。
顺便体验一下C语言的变量和函数。

直接上代码：

### 变量

```c
#include <stdio.h>

int main() {
    int a = 1;
    printf("a = %d\n", a);
    return 0;
}
```

保存成文件`var.c`，编译并运行，结果如下：

```bash
bash> gcc -o var var.c
bash> ./var
a = 1
```

和Hello World相比，第一个不同点就是：

```c
int a = 1;
```

按照C的术语，这句话的意思是我们**定义**了一个新的变量`a`，它的**类型**是`int`，**赋值**为`1`。

在C语言里，所谓**定义**就是弄出一个新的东西，给它一个名字，一个类型，再给定一个值。这样我们就可以在后面的代码里使用它了。

第二句就是用`printf`函数来打印`a`的值。

```c
printf("a = %d\n", a);
```

这里`a`的值`1`实际上被填入到`%d`那个位置了。所以`"a = %d"`变成了`"a = 1"`。

`%d`被称为`printf`函数的**格式化占位符**，它有两个作用，一个是相当于空格一样告诉系统“我们要在这里填进一个值”，另一个作用是通过`%d`告诉系统我们填入的数是整数类型的。

### 变量的类型

我们现在除了整数(`int`)和字符串类型，还没见过其他的类型，但这里大概可以看看有哪些类型，以及他们在`printf`中对应的格式占位符：

| 占位符 | 对应的类型 |
| :-------- | :------------------------------------------------- |
| %d        | 十进制整数（即decimal，所以用%d）               |
| %u        | 十进制正整数（int unsigned decimal，这里用的u指的是unsigned）                               |
| %c        | 单个字符（即character，所以用%c）
| %f        | 浮点数（floating point number，即带小数点的数）
| %s        | 字符串（string）
| %n        | 啥都不打印（那这个占位符有啥用？就占个位吧）
| %o        | 八进制整数（octal integer）                          |
| %x        | 十六进制整数（hexadecimal integer）                   |
| %i        | 整数（int，这个和%d不同之处在于让系统自己去检测到底是十进制还是其他进制）|
| %hi       | 短整数（short signed）                                     |
| %hu       | 短整数（short unsigned）                                  |
| %Lf       | 长浮点数（long double）                                        |
| %p        | 指针（即内存地址，pointer）                           |
| %e        | 科学计数法的浮点数（e表示用小e做指数底，例如：2.05e6）     |
| %E        | 同上，但是用的是大E做底     |
| %%        | '%'字符本身                                       |

是不是看了有点头晕？没事这个表不用记下来，只要知道两点即可：

1. 不同类型的数据用不同的占位符来表示，这样`printf`就知道该怎么展示它了。
2. 同样类型的数据，例如整数，也可以根据不同的占位符展示出不同的格式。 

你看，关键就是显示的**格式**（format），所以`printf`后面这个`f`就是`format`的意思。


这个表还可以看出来C语言里大概有哪些不同类型的数据：

- 整数（int，还分了普通整数和正整数两种，而且还有不同的进制可以展示）
- 小数（float，术语叫**浮点数**）
- 字符（char，即`'a'、'b'、'c'`这类单个的字符，当然`'0'`这样的数字也可以看做一个字符）
- 字符串（string，即多个字符连成一串，例如`"ABC"`或`"你好，中国"`）
- 指针（pointer，即内存地址，这个概念比较复杂，我们以后遇到了再讲）

我们暂时只需要知道这些类型就够了，接下来几章都只需要用到普通的整数（int）和字符串。

注：C有一点很麻烦，就是字符串在语言里并不是`string`类型，而是多个字符（char）所组成的数组（array）。稍后会有更详细的解释。

#### 整数

我们看看同样的整数可以打印出不同的格式：

```c
#include <stdio.h>

int main() {
    int a = 258;
    printf("a(%%d) = %d\n", a);
    printf("a(%%u) = %u\n", a);
    printf("a(%%o) = 0%o\n", a);
    printf("a(%%x) = 0x%x\n", a);
    printf("a(%%i) = %i\n", a);
    printf("a(%%hi) = %hi\n", a);
    printf("a(%%hu) = %hu\n", a);
    return 0;
}
```

打印的结果如下：

```
a(%d) = 258
a(%u) = 258
a(%o) = 0402
a(%x) = 0x102
a(%i) = 258
a(%hi) = 258
a(%hu) = 258
```

八进制下：258 = 0402，即`4*8^2 + 0*8^1 + 2*8`，即`256 + 2 = 258`。
十六进制下：258 = 0x102，即`1*16^2 + 0*16^1 + 2*16^0`，即`256 + 2 = 258`。

可惜`printf`里没有二进制的占位符，很多时候我们需要打印二进制的。

这些不同类型的整数在做底层相关计算时很有用，但是我们暂时用不到，所以接下来只用`int`即可。

#### 字符和字符串

单个字符，如`a`，`b`、`0`、`+`这类，在C语言里属于`char`类型，用单引号`''`括起来，如`'a'`：

```c
#include <stdio.h>

int main() {
    char a = 'a';
    printf("a = '%c'\n", a);
    return 0;
}
```

打印结果是：

```
a = 'a'
```

而一段文本，即一个**字符串**，则是多个字符拼起来的，用双引号`""`括起来，如`"abc"`：

```c
#include <stdio.h>

int main() {
    char s[] = "abc";
    printf("s = \"%s\"\n", s);
    return 0;
}
```

打印结果是：

```
s = "abc"
```

注意，这里字符串变量`s`的类型是`char[]`，而不是`char`。因为它是多个字符，而不是一个。在C语言里，用`[]`表示多个相同类型的数据所拼成的“一组数据”，简称为“数组”。

只是C语言的数组定义方式比较奇怪，按照常理说，既然`char`是字符的类型名称，那么字符的数组的类型名称应当是`char[]`，也就是定义应当写作：

```c
char[] s = "abc";
```

但C标准的写法却不是这样，而是把`[]`放到变量名后面。所以，正确的写法是：

```c
char s[] = "abc";
```

我猜这样设计的原因是最初数组并不是C语言的**基本类型**，而只是一种**复合数据结构**，因此并不认为`char[]`是一个具体类型，而是认为`char`是类型，`[]`是这种类型的一个组合而已。

在较新的语言中，数组已经上升为和整数、浮点数一样级别的基本类型了，所以我们一般都把`char[]`看做一个具体的类型了。

例如在Go中，数组就是这样定义的：

```go
var s []byte = []byte("abc")
```

Go的名称和类型的顺序和C相反，但表达力是一致的，因此我们可以反过来写：

```go
var []byte s = []byte("abc")
```

它把`[]byte`当做了`s`的类型定义。

后面的内容里，我仍然会简单的用`char[]`来表示字符数组，但请注意在C代码中没有这样的写法。


这样，我们可以给Hello World示例加上变量定义了：

```c
#include <stdio.h>

int main() {
    char[] s = "Hello World!";
    printf("%s\n", s);
    return 0;
}
```

结果和上一章的程序是一样的：

```
Hello World!
```

当然，如果不怕麻烦，我们也可以定义一个个的字符，再打印：

```c

#include <stdio.h>

int main() {
    char a = 'H';
    char b = 'e';
    char c = 'l';
    char d = 'l';
    char e = 'o';
    char f = ' ';
    char g = 'W';
    char h = 'o';
    char i = 'r';
    char j = 'l';
    char k = 'd';
    char l = '!';
    printf("%c%c%c%c%c%c%c%c%c%c%c%c\n", a, b, c, d, e, f, g, h, i, j, k, l);
    return 0;
}
```

结果是一样的：

```
Hello World!
```

这样显然太麻烦了，还是组合在一起成为字符串比较好用。

注意：在更标准的写法中，字符串往往不是用`char[]`来表示，而是用`const char*`。即：

```c
const char* s = "Hello World!";
```

这里的`char*`和`char s[]`是一个意思，但我们现在还不用具体关心它。
等具体了解指针的概念之后，再来讨论就比较清楚了。
而`const`修饰符是告诉编译器这个字符串是只读的，不允许修改。这是一种优化，我们也不用太早接触。


#### 数组

上面我们已经介绍了字符串，即字符类型的数组，下面看看更为通用的数组是什么样的。

比如，我们可以定义一个整数（int）类型的数组：


```c
#include <stdio.h>

int main() {
    int a[] = {1, 2, 3, 4, 5};
    printf("a[0] = %d\n", a[0]);
    printf("a[1] = %d\n", a[1]);
    printf("a[2] = %d\n", a[2]);
    printf("a[3] = %d\n", a[3]);
    printf("a[4] = %d\n", a[4]);
    return 0;
}
```

这里，声明`int a[]`和前面字符串的声明`char[] s`是一致的。但`=`右边用了不一样的形式来初始化它的值。

这是因为`{1, 2, 3, 4, 5}`这种形式才是C语言数组的标准形式。而`"Hello World!"`这种形式只是字符串的特例。

实际上，字符串也可以用这种标准形式来定义：

```c
#include <stdio.h>

int main() {
    char s[] = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'};
    printf("%s\n", s);
    return 0;
}
```

这样的可读性远远低于`"Hello World"`，而恰好文本字符串本就是程序最常处理的对象，因此C为它专门订制了`"..."`的语法。

要读取数组的某个元素，我们用`a[1]`这样的形式来访问。其中`1`是元素的下标，即第几个元素。
注意，C里下标是从0开始的，所以`a[0]`是第一个元素，`a[1]`是第二个元素，以此类推。

例如，上面的数组`a`长度是5，那么取得它第5个（即最后一个）元素的方法应当是`a[4]`，而不是`a[5]`。
如果用`a[5]`，就会出现所谓“数组越界”的错误。
这也是C初学者最容易犯的错误之一。

这里还有一个问题，就是数组的长度。实际上，上面的定义的标准写法应当是：

```c
int a[5] = {1, 2, 3, 4, 5};
```

这里可以看出，C的数组长度实际上是固定的，一旦确认之后就不能改变了。而上面的`int a[]`的写法只是编译器帮我们省略了自己数长度的过程而已，实际上编译器会读取`=`右侧的`{1, 2, 3, 4, 5}`，数出5个元素，然后确定这个数组是`int a[5]`。

C的数组长度固定，且数组定义之后也是固定的了，我们没法像Python那样把一个数组变量赋值为另一个数组变量：

```c
int main() {
    int a[] = {1, 2, 3, 4, 5};
    int b[] = {6, 7, 8, 9, 10};
    b = a; // ERROR: assignment to expression with array type
    return 0;
}
```

这里`b=a`会报错。这是因为b的实际类型是指向b[0]的地址，即`&b[0]`，这个地址是固定值，只能用来访问，不能修改。
要理解这一点，还得深入了解了指针之后再考虑。

如果要想改变一个数组，里如让它变长，该怎么做呢？这也需要用到指针，因此我们后面再讨论。

总之，没有指针的配合，C语言的数组就是个半成品的感觉。

指针的内容比较复杂，我觉得不适合放在这里解释，因此接下来的章节我先尝试不用指针，看看能做到哪些事情。等到不得不用指针的时候，再来深入展开讨论。


#### 变量的重复定义

在C语言里，变量名是不能重复定义的，否则会报错：

```c
#include <stdio.h>

int main() {
    int a = 1;
    int a = 2;
    printf("a = %d\n", a);
    return 0;
}
```

结果是：

```c
error: redefinition of 'a'
```

`a`被重新定义了两次，后面`printf`时就不知道用的是哪一个`a`了。

但实际上这种限制并不是必须的，如果让编译器加个规则，最新定义的变量会覆盖之前的变量，就没有问题了。
很多新的编程语言，例如Rust，就允许这么做。


### 函数

现在我们有了自己定义变量的能力，就可以开始写函数了。

让我们先写一个最简单的加法：

```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 40;
    int y = 2;
    int z = add(x, y);
    printf("%d + %d = %d\n", x, y, z);
    return 0;
}
```

结果是：

```c
40 + 2 = 42
```

这里的`add`是我们自己定义的新函数。

自己定义的函数名字可以随便起，只要别和已有的函数名称冲突就行了。
所以我们换个名字也一样：

```c
#include <stdio.h>

int sum(int a, int b) {
    return a + b;
}

int main() {
    int x = 40;
    int y = 2;
    int z = sum(x, y);
    printf("%d + %d = %d\n", x, y, z);
    return 0;
}
```

结果是一样的：

```c
40 + 2 = 42
```

上面把`add`名字改成了`sum`，并没有变化。



#### 函数的参数

它和`main`这样的函数差不多，只是多了两个输入值`a`和`b`，称为**参数**（parameter）。
这里的两个参数我们也指定了类型，都是`int`。两个整数加起来还是整数，所以`add`的返回类型也是`int`。

可以看出来，在`add`函数里，`a`和`b`就相当于定义了两个变量，用起来是一样的。

`add`函数里只有一个语句：

```c
return a + b;
```

也就是说，返回的值是`a+b`的和。

而我们在`main`函数里调用`add`函数时，我们写的是`add(x, y)`，即告诉`add`函数，`a`=`x`=40，`b`=`y`=2，因此返回的`a+b`=42。


#### 函数的作用域

C语言的函数参数还有个特点，就是它只在函数里头有效，函数外头是看不到的。

```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 40;
    int y = 2;
    int z = add(x, y);
    printf("%d + %d = %d\n", x, y, z);
    printf("a = %d\n", a); // ERROR: a is not defined
    return 0;
}
```

这段代码会报错，因为`a`是定义在`add`函数内部的参数变量，`main`函数里是看不到它的。

我们把这种能够看见的范围叫做**作用域**（即scope，我认为翻译成"视野"或"视域"更贴切）。

在C语言里，基本上每个花括号都打开一个新的小世界，一个小视野，在那里头定义的新变量，只能在这个小世界里头看见，出了这个小世界就看不见了。

函数的新视野是从参数列表的`()`开始的，因此`a`和`b`的视野和`add`函数的花括号是一样的。


#### 全局变量

相反的，在一个作用域里，可以看到它之外定义的变量。

例如，如果我们在所有的函数之外单独定义一个变量，那么它的作用域就最广了，到处都能看到它。
这种变量叫做**全局变量**。

例如：

```c
#include <stdio.h>

int g = 100;

int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 40;
    int z = add(x, g);
    printf("%d + %d = %d\n", x, g, z);
    return 0;
}
```

结果是：

```c
40 + 100 = 140
```

这里的变量`g`是写在源码的顶层的，因此是个全局变量，它的作用域是整个源码文件，到处都能看到它，包括`main`函数里头。

那么，`add`函数里能看到`g`吗？答案是当然可以。

那么，`add`函数里能看到`x`吗？并不行。

```c
int z = add(x, g);
```
 
这句话的意思是用`x`和`g`的值当做参数来调用`add`，实际上是有一个隐藏的`a=x`,`b=g`的过程的。

`x`变量本身并没有被送到函数`add`里。我们说的作用域或者视野，指的是在代码里的层级关系，和实际运行时的调用是没关系的。

所以，除非把`x`定义在`add`函数的外面，否则`add`函数里是看不到`x`的。而在这个例子里，`add`外面就只有全局变量了。

在C语言里，通常把函数定义的参数叫做“形参”（formal parameter，简称为parameter），即`add`定义里的`a`和`b`；
而把调用函数时实际使用的变量叫做“实参”（actual parameter，为区分，简称直接换了个英文词，argument），即`main`里的`x`和`g`。

这俩是不一样的。但我也说不清楚为啥要区分形参和实参。所以读者也暂时不管他了吧，只要知道有人（比如面试官？）关心这种区别就行了。

对我而言，只要知道调用函数时有这么一个类似`a=x`，`b=g`的值传递过程就行了。

#### 同名参数

最后我们来看一个有点奇怪的例子：

```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main() {
    int a = 40;
    int b = 2;
    int c = add(a, b);
    printf("%d + %d = %d\n", a, b, c);
    return 0;
}
```

这里`add`里有`a`和`b`，`main`里又定义了`a`和`b`，甚至还用它们去调用`add`函数了。会不会报错呢？

答案是不会：

```
bash> gcc -o add add.c
bash> ./add
40 + 2 = 42
```

正常出结果了。你可能会问，这里`a`和`b`没有重复定义吗？

答案是没有。这也正是作用域的规则所导致的：

- `add`里的`a`和`b`的作用域是`add`函数内部
- `main`里的`a`和`b`的作用域是`main`函数内部

这两个作用域并没有交叠，因此这两对`a`和`b`并没有关系，也不会遇到。

在调用`add`的过程中，如果看做是`add.a=main.a`和`add.b=main.b`，就不会感觉冲突了。

### 小结

本章记录了C语言的变量和函数的基本概念，包括：

- 变量的定义和使用
- 自定义函数
- 函数的参数和返回值
- 初步接触作用域

因此是第一次接触，我并不打算追求全面性和深度，只把大体概念讲清楚就行了。
后面的章节还会遇到变量和函数的更多应用，随着应用的深入，再逐步揭开它们的细节吧。

### 如何改进？

C语言的变量定义和函数定义我觉得没毛病，挺好用的。但随着时代发展，新的语言还是做出了语法上的改变。

#### Z语言的变量

在定义语法上，Rust和Go之类的语言都做出了如下改变： 

- 为了方便编译器解析，给变量的定义和函数的定义都分配了专门的关键字作为引导。
- 在编译器层面增加了类型推导，很多情况下程序员不需要写出变量或参数的类型，而是让编译器自己去猜。
- 由于类型推导的存在，变量的类型变成可以省略的了，这时候多个定义一起写的时候，为了对其方便，有的语言把变量名放在前面，类型放在后面，中间加一个冒号分隔。

这些改变我认为也算不上改进，因为实际上的语法表达力是一样的。

但不可否认这种改变确实让代码显得更清晰了，也更容易解析，考虑到Z语言的编译器我要自己写，因此我也选择了这些改变。

另外，C语言里量有三种：

- 普通变量：类型固定、值可以变
- 不变量：类型固定、值不变，即const，我们会在后面用到的时候详细解释。字符串的`const char *`就是这种类型。
- 宏常量：相当于在代码中直接写下的量，如3.1415926。为了方便在代码中多个地方引用和修改方便，C利用`#define`宏来模拟了常量的定义。后面会介绍到。

这三种方式显然并不够统一，在语法设计上有些混乱。因此，更新的语言引入了新的关键字类统一表示这些不同类型的量。

在Z语言中，我们根据变化的灵活程度设计了三种类型的量：

- 常量，在编译器确定值，之后类型和值都不可编。常量通常用来表示一些自然界固定的值，如圆周率`PI`。Z语言中常量的关键字是`const`，且只允许作为全局量定义。
- 标量，编译期确定类型，运行时初始化值，之后不允许再改变。标量通常用来表示一些程序运行过程中不会改变的值，在函数式编程中很好用。Z语言中标量的关键字是`let`。
- 变量，编译期确定类型，运行时初始化值，之后可以改变。变量通常用来表示一些程序运行过程中会改变的值，和C语言的变量一致。Z语言中变量的关键字是`mut`。
- 幻量，类型和值都可以随时变幻。和动态语言的变量一致。Z语言中任意变量的关键字是`var`。

下面是Z语言中变量和函数的语法展示：

```c
// 常量定义，只能作为全局量
const PI = 3.1415926

fn main {
    // 标量定义
    let x = 10
    x = 14 // Error: 标量值不能改变
    // 变量定义
    mut y = 10
    y = 12 // 变量值可以改变

    // 指定类型时直接在量名之后空格加类型名称即可
    let z str = "Hello"

    // 类似Javascript任意变量，可以接收任何类型的值 
    var v = 10
    v = "String" // 可以变化类型 
}
```

#### Z语言的函数 

C语言的函数定义并没有专门的关键字提示，所以阅读时并不够清晰。之后的语言都引入了函数定义关键字：

- Javascript: `function`
- Python: `def`
- Go: `func`
- Rust: `fn`

他们的意思都一样，表示接下来的代码是一个函数的定义。Z语言选择了最简单的`fn`，实在是因为没法再简略了，简化到极致就是`f`，可读性较差。 

Z语言函数的定义如下： 

```c
use io

fn add(a int, b int) int {
    a + b
}

fn main {
    io.println(add(1, 2))
}
```

可以看出，Z的语法更接近Go。参数类型和返回值类型都直接用空格来界定，在有语法高亮的前提下，并不影响可读性。

另外，不同于Go的是，Z语言默认将最后一行表达式作为整个函数的返回值，而不用写明`return`。

Z语言函数的调用方式和C基本一致。另有扩展的地方再未来有需要的时候再讲。